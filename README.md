# Кирпикова Кристина ИТ-15,16
## Вариант 9
### Задача 1.1
@Invoke.  
Разработайте аннотацию @Invoke, со следующими характеристиками:  
• Целью может быть только МЕТОД  
• Доступна во время исполнения программы  
• Не имеет свойств  
Создайте класс, содержащий несколько методов, и проаннотируйте хотя бы один из них
аннотацией @Invoke.
Реализуйте обработчик (через Reflection API), который находит методы, отмеченные
аннотацией @Invoke, и вызывает их автоматически.
### Алгоритм решения
Создаем объект студент, используем уже готовый класс, добавляем метод, выводящий информацию о студенте, и помечаем его аннотацией. Создаем обработчик, проверяем на существование. Получаем все методы класса, 
проверяем помечены ли они аннотацией @Invoke, делаем метод доступным, вызываем его с оброботкой исключений. Метод автоматически выполняется и выводит данные студента
### Пример
<img width="843" height="591" alt="Снимок экрана 2025-12-14 132357" src="https://github.com/user-attachments/assets/95113f36-bd48-4268-b187-2afbb346c559" />  

### Задача 1.2
@Default.  
Разработайте аннотацию @Default, со следующими характеристиками:  
• Целью может быть ТИП или ПОЛЕ  
• Доступна во время исполнения программы  
• Имеет обязательное свойство value типа Class  
Проаннотируйте какой-либо класс данной аннотацией, указав тип по умолчанию.
Напишите обработчик, который выводит имя указанного класса по умолчанию.
### Алгоритм решения
Даем аннотацию классу Точки. Создаем объект. Создаем обработчик, получаем класс объекта, проверяем наличие аннтоации, получаем значениею
выводим имя класс по умолчанию, указанный в аннотации.
### Пример
<img width="764" height="307" alt="Снимок экрана 2025-12-14 132934" src="https://github.com/user-attachments/assets/348126aa-eb9a-4b4f-9eda-1529de7bb7d5" />  

### Задача 1.3
@ToString.  
Разработайте аннотацию @ToString, со следующими характеристиками:  
• Целью может быть ТИП или ПОЛЕ  
• Доступна во время исполнения программы  
• Имеет необязательное свойство valuec двумя вариантами значений: YES или NO  
• Значение свойства по умолчанию: YES  
Проаннотируйте класс аннотацией @ToString, а одно из полей – с @ToString(Mode.NO).
Создайте метод, который формирует строковое представление объекта, учитывая только те поля,
где @ToString имеет значение YES.
### Алгоритм решения
Добавляем аннотацию в класс Кота. Даем исключение полю "порода". Создаем объект кота. Создаем обработчик, проверяем наличие аннотации, получаем все поля. Если у поля нет аннотации или аннотация "YES", то
добавляем его в строку. Выводим строку с инормацией о коте, без породы.
### Пример
<img width="919" height="414" alt="Снимок экрана 2025-12-14 133617" src="https://github.com/user-attachments/assets/5f9f9512-89fc-4cc7-a787-8144f984744e" />  

### Задача 1.4
@Validate.  
Разработайте аннотацию @Validate, со следующими характеристиками:  
• Целью может быть ТИП или АННОТАЦИЯ  
• Доступна во время исполнения программы  
• Имеет обязательное свойство value, типа Class[]  
Проаннотируйте класс аннотацией @Validate, передав список типов для проверки.
Реализуйте обработчик, который выводит, какие классы указаны в аннотации.
### Алгоритм решения
Добавляем аннотацию для класса 3д Точки. Создаме объект 3д точки. Создаем обработчик, проверяем наличие аннотации, извлекаем массив клкассов, выводим список классов указанныз в аннотации.
### Пример
<img width="783" height="413" alt="Снимок экрана 2025-12-14 183335" src="https://github.com/user-attachments/assets/00652c1c-8c8e-4d89-b4ce-b6878570c9f6" />  

### Задача 1.5
@Two.  
Разработайте аннотацию @Two, со следующими характеристиками:  
• Целью может быть ТИП  
• Доступна во время исполнения программы  
• Имеет два обязательных свойства: first типа String и second типа int  
Проаннотируйте какой-либо класс аннотацией @Two, передав строковое и числовое значения.
Реализуйте обработчик, который считывает и выводит значения этих свойств.
### Алгоритм решения
Добавляем аннотацию для класа Кот, указываем значения. Создаем объект кошка. Создаем обработчик, проверяем наличие аннотации, проверяем правильно ли обозначены значения аннотации. Существует ли строка и положительное
ли число, если проверка не пройдена, выбрасываем исключение. Выводим значения аннотации, если они указаны верно.
### Пример
<img width="905" height="309" alt="Снимок экрана 2025-12-14 184241" src="https://github.com/user-attachments/assets/2faae51b-673d-42f1-a8ef-5223a0367aed" />  

### Задача 1.6
@Cache.  
Разработайте аннотацию @Cache, со следующими характеристиками:  
• Целью может быть ТИП  
• Доступна во время исполнения программы  
• Имеет необязательное свойство value, типа String[]  
• Значение свойства по умолчанию: пустой массив  
Проаннотируйте класс аннотацией @Cache, указав несколько кешируемых областей.
Создайте обработчик, который выводит список всех кешируемых областей или сообщение, что
список пуст.
### Алгоритм решени
Добавляем аннотацию для класса 2д Точки, указав кэшируемые области. Создаем обработчик, проверяем наличие аннотации, проверяем наличие массива. Если массив пуст, выводим сообщение об ошибке.
Если проверка пройдена, выводим кэшируемые обюласти.
### Пример
<img width="870" height="444" alt="Снимок экрана 2025-12-14 185117" src="https://github.com/user-attachments/assets/d5562ad8-4079-4a87-93b7-62214f4328cc" />  

### Задача 2.4
Написать тест, используя фреймворк JUnit, который проверяет корректность работы механизма
валидации классов, отмеченных аннотацией @Validate.  
• Создать класс с аннотацией @Validate, указывающей массив типов для проверки.  
• Использовать тест, который вызывает обработчик и проверяет, что список классов,
переданный в аннотации, корректно извлекается и при передаче пустого массива
выбрасывается исключение IllegalArgumentException.  
• В тесте использовать аннотацию @Test с параметром expected (или assertThrows в JUnit 5).
### Алгоритм решения
Создаем тестовый класс. В методе получаем класс обьекта, проверяем есть ли аннотация, если нет, выбрасываем ошибку. Берем массив классов из аннотаци, проверяем не пуст ли он. Если ошибка не выбрасывавется - тест пройден, в противном случае тест не пройден. Чтобы показать корректность работы программы создаем класс с пустым массивом в аннотации.
### Пример
<img width="1120" height="333" alt="Снимок экрана 2025-12-14 191034" src="https://github.com/user-attachments/assets/34df3ea0-202d-4bbd-9bbf-c23e558bbb0e" />  

### Задача 2.6
Разработайте тест, используя фреймворк JUnit, проверяющий корректность обработки
аннотации @Two, если её свойства заданы некорректно. Например, строковое свойство first пустое
(""), а числовое second отрицательное.  
• Создайте вспомогательный класс с аннотацией @Two(first = "", second = -1).  
• В тесте реализуйте метод, который через Reflection считывает значения аннотации.  
• Если одно из свойств нарушает ожидаемые условия (first – пустая строка, second < 0), то
должен быть выброшен IllegalArgumentException.  
• Используйте assertThrows() из JUnit для проверки выбрасываемого исключения.  
### Алгоритм решения
Создаем тестовый класс. Создать вспомогательный класс с некорректной аннотацией по примеру задачи. Через рефлексию вызываем метод, и проверяем срабатывает ли исключение.
### Пример
<img width="1227" height="426" alt="Снимок экрана 2025-12-14 191300" src="https://github.com/user-attachments/assets/871ab36e-daf9-4e71-8da4-2242bbaa1aee" />  

